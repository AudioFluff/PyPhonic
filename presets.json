[
    {
        "id": 1,
        "name": "Init (Plain Python)",
        "code": "import pyphonic\ndef process(midi, audio):\n    return midi, audio"
    },
    {
        "id": 2,
        "name": "Init (Python with NumPy)",
        "code": "import numpy as np\nimport pyphonic\ndef process_npy(midi, audio):\n    return midi, audio"
    },
    {
        "id": 3,
        "name": "Butterworth Filter (High, Low or Bandpass)",
        "code": "import pyphonic\n\nimport numpy as np\nfrom scipy.signal import butter, sosfilt\n\norder = 6\nfs = None\nsos = None\ncutoff = 500\nZl, Zr = None, None\n\ndef process_npy(midi, audio):\n    global Zl, Zr, fs, sos\n    if fs is None:\n        fs = pyphonic.getSampleRate()\n        sos = butter(order, cutoff, fs=fs, btype='lowpass', analog=False, output='sos')\n        Zl = np.zeros((sos.shape[0], 2))\n        Zr = np.zeros((sos.shape[0], 2))\n        return midi, audio\n    left = audio[:audio.shape[0]//2]\n    right = audio[audio.shape[0]//2:]\n    left, Zl = sosfilt(sos, left, zi=Zl)\n    right, Zr = sosfilt(sos, right, zi=Zr)\n    return midi, np.concatenate((left, right))"
    },
    {
        "id": 4,
        "name": "Midi Arpeggiator, minor triad",
        "code": "import pyphonic\nfrom pyphonic import MidiMessage\n\ntimer = 0\nmidibuf = {}\ninitial_delay = 0\nduration = 1\narp_delay = 7\n\ndef add_note(beats_from_now, type, note, velocity, channel):\n    global midibuf, timer\n\n    bpm = pyphonic.getBPM()\n    \n    bps = bpm / 60\n    ticks_per_second = bps * 1000\n\n    blocks_per_second = pyphonic.getSampleRate() / pyphonic.getBlockSize()\n\n    ticks_per_block = ticks_per_second / blocks_per_second\n\n    tick_skip = 1000 * beats_from_now\n    \n    blocks_in_future = tick_skip / ticks_per_block / 4 # assume 4/4 time\n\n    when = int(timer + blocks_in_future)\n\n    midibuf[when] = midibuf.get(when, [])\n\n    new_note = MidiMessage(type, note, velocity, channel)\n    if type == "note_off":\n        new_note.velocity = 0\n    midibuf[when].append(new_note)\n\ndef process(midi, audio):\n    global timer, midibuf\n    for msg in midi:\n        if msg.type == "note_on":\n            when = initial_delay\n            add_note(when, "note_on", msg.note, msg.velocity, msg.channel)\n            when += duration\n            add_note(when, "note_off", msg.note, msg.velocity, msg.channel)\n            when += arp_delay\n            add_note(when, "note_on", msg.note + 3, msg.velocity, msg.channel)\n            when += duration\n            add_note(when, "note_off", msg.note + 3, msg.velocity, msg.channel)\n            when += arp_delay\n            add_note(when, "note_on", msg.note + 7, msg.velocity, msg.channel)\n            when += duration\n            add_note(when, "note_off", msg.note + 7, msg.velocity, msg.channel)\n    \n    for k in list(midibuf.keys()):\n        if k < timer:\n            del midibuf[k]\n\n    timer += 1\n\n    return midibuf.get(timer - 1, []), audio"
    }
]